hi everyone welcome back to
another video in the web security
academy series in the previous video we
covered the second lab
in the sql injection module so we got
some hands-on experience by exploiting a
sql injection
in the login functionality of the
application that allowed us to
bypass authentication and eventually we
were able to
log in as the administrator user without
knowing the
administrator's password i've added the
link to the previous video in the
description if you want to check it out
in today's video we'll be covering lab
number three
this lab will leverage a sql injection
union attack that will allow us to
extract
information from the backend database
all right let's get started if you do
not have an account
you can get one by visiting the url
portswigger.net
web security and clicking on the sign up
button
i do already have an account and i am
logged in so
to access the academy i'm going to
select academy
go down select the learning path
select sql injection
select sql injection union attacks and
then click on the first lab
and it's titled sql injection union
attack determining the number of columns
returned by the query
so let's open that in a new tab
all right let's look at the description
so this lab contains a sql injection
vulnerability in the product category
filter
so we've got an sqli and it's in the
product category filter
the results from the query are returned
in the applications response so you
could see them in the browser
and it says so you can use a union
attack to retrieve data from other
tables
we'll learn what that is in a second the
first step of such an attack
is to determine the number of columns
that are being returned by the query you
will then use this technique in
subsequent labs to construct the full
attack
all right so what this exercise is
saying is
that you've got a certain parameter
the category filter that is vulnerable
to sql injection
now the way we want to exploit this
filter or this category parameter
is by running a sql injection union
attack
and eventually being able to retrieve
data from other tables
so we're not interested in for example
the products table
we're more interested in tables like a
user's table that contains
the authentication credentials uh to the
users of the application
so we'll do a uni we'll we'll perform a
union attack that will
allow us to retrieve data from other
tables however this is not done in one
step
it's done in multiple steps and one of
the first steps
in order to exploit this vulnerability
is to determine the number of columns
that are being returned by the query
that filters on category and then
once we're done that step there are a
couple of more steps that will be done
in subsequent labs in order to construct
the full attack
so in order to learn how to run uh this
attack it's gonna
take i believe about two or three videos
before we can actually extract data from
the backend database
all right so the end goal over here for
today's exercise
is to solve the lab determine the number
of columns returned by the query by
performing a sql injection union attack
that returns an additional row
containing null values
so the end goal is to determine
the number of columns
returned by the query
and we'll do that by exploiting the sql
injection vulnerability
all right so before we access the lab
we need a little bit of background
knowledge
on how the union operator works
all right so take for example you've got
two tables table one
and table two
table one has two columns a b
and table two has two columns c and d
now table 1 contains the values 1 2
table 2 contains the values 2 3
and then table 1 also contains the
values 3 4
and table 2 contains the values 4 5.
now imagine you have this query over
here
select a and b from
table one so select columns a and b
from table one the result of this query
would be the
values in those columns so it would be
one
two and three
four now
let's do a query that uses the union
operator
so the same query above so select a
b from table 1
union select
cd from table 2.
all right so what the union operator
does over here
is it concatenates the results of the
two queries into a single result
set so it'll run the first query select
a b
from table one so the result is one two
three four and then it'll concatenate
that result with the one of the second
query with the result of the second
query which is select
column c and d from table two and that
would be
two three
four five and the results are displayed
into one single uh result set so in
in the same table all right so now you
might be wondering well how does this
relate to
a sql injection attack now imagine
you have this query over here
and all it does is it displays
products from a product table now i'm
not interested in seeing the
products in the product table i care
about more tables
uh for example the users table that
contains the username
and hashed passwords of all the users
of this application over here and so
what i can do
if this is vulnerable to sql injection i
can
add this query over here
let's say say users table
so i'll inject this query over here that
says
don't just give me the the products in
the product table
but also give me the usernames
and passwords from the users table in
this way it allows me to extract
information from other tables
that are being used by the backend
database
now before we even get to the sql
injection attacks
it's important to know that there are
certain rules that
you need to follow when you when you're
using the union operator
and we'll get those from the official
microsoft documentation
union operator sql
so if you go down you could see over
here
the the function of the union operator
is that it concatenates the results of
two queries into a single result set
just like we saw for those two tables
over here
and then it says the following are basic
rules for combining the
result sets of two queries by using
union so the first rule
is that the number and the order
of the columns must be
the same in all queries
and we saw that this is the case for our
query over here
so uh the number of columns that were
called in the first query are two
a and b and then the number of columns
that are called in the second query from
table two are also two
c and d so we satisfy this rule and the
second rule is that the
data types
must be compatible
and we saw over here all the columns a b
c and d
are of type integer and that's why this
query works and doesn't throw
an error or an exception all right
okay now that we know how to use the
union query
how can we apply it in order to achieve
our end goal which is to determine the
number of columns
returned by the query so
let's say sql injection attack
imagine you have an application that is
running
that is running a query at the back end
however because you're
you're doing a black box pen test you
don't have access to the code
and you don't know the number of columns
that are being
used in that query so let's say question
mark over here and
it's from say table1
now if this query is vulnerable to a sql
injection
you can use the union operator in order
to determine the number of columns
by iteratively
doing a bunch of requests that determine
the number of columns and the way we're
going to do that is we'll do
union select null value
now if the number of columns is not the
same in this query
so in the second query over here if the
number of columns is not the same to the
number of columns that are being called
in the first query then we'll get an
error and if we get an
error
then we know that the number of columns
is not just
one so we know that it's
incorrect number of
columns and so we'll keep
running this request over here
iteratively until we no longer get an
error so instead of using one null
we'll use two null values and again if
you get an error that means
the number of columns over here is
incompatible with the number of columns
over here
and so you still haven't gotten the
correct number of columns
until you keep iteratively doing this
and then if you end up getting a 200
response code
then you finally reach the correct
number of columns
and we'll see how to do that in the
exercise all right so that's way number
one
and that is how the zwigger wants us to
complete the
exercise but there is a different way
which is a little bit cleaner
and let's learn that as well
so let's say away number two
and what that uses is the order by
clause
so let's say order by sql
and again we'll look at the microsoft
documentation
so it sorts data returned by a query in
the sql server
all right so if you've got
a query that says select a b
from table one and then it
says order by one what that will do is
it will order by the first column
if i said order by two it'll order by
the second column which is b
if i said order by three that column
does not exist
and so it will throw an error and this
is another way of
determining the number of columns that
are being used by the query
because what i can do is i can
iteratively keep increasing this number
to you know one two three four so on
until i get an
error once i get an error that means the
column that i'm trying to order by
does not exist and therefore this gives
away that number of
columns that are being used in the query
and so we'll do both methods in the
exercise right i'm going to close this
and let's access the labs
and this might take a while
okay so it looks like we've got a
shopping
application you can refine your search
based on category so this is the field
that is vulnerable if we look back
at the end goal over here this is the
field that is vulnerable so if i select
gifts
it'll only show me the items that are
related to this category so the items
that are related to
gifts and if you look over here in the
url
this is the category parameter and this
is where it gets filled out now
since this is the field that is
vulnerable i'm just going to run a basic
test case so a single quote to see if it
breaks the application
and it does so we get an internal server
error this leads me to believe that it's
vulnerable to sql injection
uh because what what happens is that i
introduced a character
into the sql query and it through a
syntax error which resulted in an
internal server error
now to confirm that it is vulnerable to
sql injection i'm going to give it a
value that is correct
so won't break the query so i'm going to
comment out the rest of the
query and if that returns a 200 response
code then i'm convinced that it is
vulnerable to a sql injection
all right so that's good let's go back
to our general use case which is just
selecting gifts
all right so now i need a way
to determine the number of columns
returned by the query
as the angle states over here and we
learn two ways let's apply way number
one
which uses the null values
so i'm going to close the query over
here
and say union select
null
and hit enter i get an internal server
error which leads me to believe
that there isn't only one column in the
query and that makes sense
because it looks like just based on the
information that is displayed in the
response it looks like the query has to
have at least
a column that displays the name of the
product it also has to have a column
that displays the price of the product
and a column that uniquely identifies
the product so some kind of id column
that is not getting displayed
in the response and so my guess is it
has three columns
but let's apply uh let's apply this
attack
iteratively so that it works in every
use case and to do that
i'm going to use burp suite for those of
you that don't know what this
is it's a proxy that sits in the middle
between my browser
and the application
and this way any requests that i make in
the browser will get intercepted
through first and then get sent to the
application similarly any responses that
come back from the application go
through burp first and then to my
browser
and click no over here
let's close it yes all right
i'm going to tell my browser i'm using
epoxy proxy extension and i'm going to
tell it to
use burp as the proxy and i'm going to
hit enter
and you'll see over here it intercepted
the request i'm going to send that to
repeater
and remove the intercept turn it off
okay let's go to repeater all right
so over here
let's make that a little bit bigger
all right so over here
we exploited the sql injection by saying
union
select
null and then comment out the rest of
the query
and then you need to url encode that the
browser does that for you but in this
case you're using the proxy so it's ctrl
u
and then hit send
and then in the response over here you
get an internal server error
and let's put that side by side so that
we could see it all right so
over here we added only one column and
it was incompatible
with the backend query that does the
filtering and so
it gave us an error now let's add
another one
and see if that works
so for the space we'll just add a plus
we still get an internal server error so
it has more than two columns
let's add another null so in this query
right over here i have three columns
right now
hit enter we still get an internal
server error but notice over here that
we forgot
a comma let's hit it again
and we get a 200 okay response if you
notice over here
it says congratulations you solved the
lab and what that means is that the
number
of columns in this query matches the
number of columns
in the query that is responsible for
filtering
based on category and so now we've
determined that the number of columns
is equal to three so that's the first
way of doing it the second way
was using the order by clause
so order by
so what this does is it'll order by
the first column
so ctrl u to url in code hit send
and we get an invalid request
and that is because this was incorrectly
done here we go
send say enter sorry space
okay perfect all right so this is
ordering by the first
column this is much better to do through
the browser because you could actually
see it order the results
uh so we'll do that here instead of the
proxy
okay so notice over here nothing got
ordered which leads me to believe the
first
column is one that we don't see which is
likely to be the
id value id column that uniquely
identifies
the gift items so let's try two
now two should be this column over here
so these
entries should be ordered based on
the first letter of the alphabet and we
saw that happen over here
perfect now let's do three and that
should be the price
column so it should be ordered in
ascending order
and here we go so you've got 27 45 98
and 99
perfect so we know that there are three
columns
let's do four and we get an error and
the reason again we get an error is
because
chances are the query through an error
that this
does not exist or is out of bound and
this resulted in an error at the
application level
all right so now we know that the number
of
columns is four minus one which is three
so we've successfully completed the end
goal of this exercise by exploiting it
manually
now let's try and do this using a script
and again if you're new to this channel
the reason i do this
is because as a pen tester you're going
to come across
many scenarios where you won't be able
to exploit things manually so
or it's a little bit unrealistic to
exploit things manually and that's why
we always write
scripts for all the attack vectors that
we do right the first thing i'm going to
do
is import the request library
and that library is responsible for
making the
get and post requests next i'm going to
import the sys library
and the url lib
3 library so we import these three
libraries in every
every script that we write i'm
also going to add this line over here
to disable any warnings when i'm running
the script
so insecure request warning
i'm gonna set my proxy so what this
uh what this line does it sets a
configuration for my script so
that any requests i make go through my
proxy and this is very useful
for seeing the requests that the script
is making and this way you could debug
them
in case things don't go as expected
so https
okay let's write the main method
there's two equal signs over here
right you've gotta try and accept clause
okay so the way i want my script to work
is i want to run it so let's say script
dot py
and i give it an a url and then
it exploits the sql injection
vulnerability so
the first thing that i'm going to do is
i'm going to set a url parameter
so url variable and take that from the
command line arguments
when running the script
and if i don't give it the correct
number of command line arguments
so if it throws index err
i wanted to print
the usage and example instructions so
usage is
like v0
and then an example
name of the program and then let's say
www.example.com
and again name of the program
all right and then i wanted to end the
program
because i didn't run it correctly all
right
so let's run this see if we get any
errors
and enter okay we don't get any errors
so that's good so what happened over
here is i didn't give it the correct
number of arguments
and so it threw an exception instead of
printing out the exception code
it printed out the usage instructions
and
an example of how to run the program all
right that's good
up next if i gave it the correct
arguments
i wanted to print statement saying
that it's trying to figure out
the number of columns
and then i'm going to create a new
variable number of
rows sorry number of columns
and we'll get that value from the
function exploit
sqli
column number
and it takes in the url all right so i'm
going to write a function we'll do that
in a second
i will write a function that exploits
the sql injection vulnerability in order
to determine the number of
columns and if number of columns is not
eq
well too false so it's it evaluates to
something
i want it to print
the number of row or the number of
columns
returned by returned in the query
let's just say the number of columns is
and then add it so string version
of number of columns
and then also
add a dot because punctuation matters
all right and otherwise
i wanted to print
that the sql injection was not
successful
asqli attack
was not successful
all right let's remove this so that we
have more space
okay that looks much better all right so
now we need to write this function over
here
so exploit sqli again it takes in the
url
let's go back to burp to see how the
request looks
and we'll make that smaller
all right so the path is this one over
here
let's copy that
and then the we'll do 4i
in range 1 250.
so that's the number of columns that i'm
going to try the sql
payload
let's just say a sql payload is equal to
order by
us comment out and then that would be
the i value that we're at
all right so what this means is that i'm
going to
iteratively try requests from 1 to 50
until i can successfully determine the
number of columns that are being used by
the query now 50 is an arbitrary number
that i selected
because i know for sure that the
application won't have 50 columns
all right so if we need to make the
request
and we know over here that it's a get
request so don't
get
that would be the url plus the path
plus the sql payload
and then we'll set verify to be equal to
false because i don't want to verify
certificates
and then proxies is equal to proxies
because i want this request to go
through my proxy
all right and then we'll
take in the response code and
set it into the variable res and then
if we see in the response that it has
the string internal server
error
and will return i minus 1
so that's the number of columns
otherwise we'll keep iteratively
increasing
uh the i value and then if that doesn't
work we just return
false all right
so what the script is going to do is
it'll start with i is equal to one it'll
test it out
if it doesn't get an internal server
error then it'll increment
i so it'll try to again
if it so it timed out over here we'll
fix that in a second
if it doesn't get an internal server
it'll try three and so on until it gets
an internal server error once it does
get an internal server error that means
that column not does not exist we can't
order by that column because it does not
exist and so the number of columns that
are being used by the
by the backend query is is i minus one
so that number of column that we were
testing
that we're currently testing with minus
one um
all right so we're going to have to
reload this because
it timed out
and then we'll run our script
let's clear this
and give it the url
so that's the new url let's copy it
and that did not copyright
okay here we go
hit enter let's see if we get any errors
okay good we don't get any errors it's
trying to figure out the number of
columns right now
and i'm noticing right now that this is
not url encoded so this is not going to
work
so i'm going to stop this before it
tries 50 times
i'm going to clear it
and let's url encoders so the spaces
you could use plus signs
all right so this should work let's try
it one more time
and it's taking an unusual number of
times which leads me to believe that
this is not working properly so this is
when verb comes in handy i'm going to
look at the requests that it's making
and try to figure out why it's not
working so you could see it's already at
number 33
which is clearly not correct so let's
look at it
and again i want it side by side
okay here we go so this is what's wrong
we've got
we've got two slashes one that we added
so if you clear over here
one that we added in the url and then
one that we added in the path
and so i can't seem to find it let's
remove that
hit save and then run the program again
so you could see it's making here we go
and that worked so it says figuring out
the number of columns and the number of
columns is three
so let's look at that over here you'll
see it ordered
by the first column it got a 200 okay
response so it increased
the value of the parameter i and then it
did two and that still got a 200
response it tried three that got a 200
response it tried four it got an
internal server error which means that
we
tried to order by a column that does not
exist
and so the number of columns would be
four minus one which is 3.
all right so we've successfully
completed the exercise
to recap in this video we first manually
ran
a sql injection union attack in order to
determine the number of rows that are
being used by the backend query we then
scripted that exploit so that it
automatically does that for us
in the next lab we'll learn how to
determine the type of data that is
stored in the column which will
eventually help us run an
attack that will end up with us
extracting information
from more interesting tables again like
the user's table that has
the hash passwords in it you can find
the link to the script in the
description
if you like the video hit the subscribe
and share button so that it reaches a
wider audience also comment below what
you learned in the video
and what you would like to see more of
in the future see you in the next video