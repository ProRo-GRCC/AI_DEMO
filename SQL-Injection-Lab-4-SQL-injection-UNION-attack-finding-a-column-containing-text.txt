hi everyone welcome back to another
video in the web security academy series
in the previous video we covered the
third lab in the sql injection module
so we got some hands-on experience by
exploiting a union-based sql injection
in order to determine the number of
columns that are being returned by the
vulnerable query
in today's video we'll be using a union
based sql injection
in order to determine the data type of
the columns that are returned by the
vulnerable query which is step number
two in the union based sql injection
attack
if you don't have an account on the web
security academy you can get one by
visiting the url portswigger.net
web security and clicking on the sign up
button
i already have an account and i am
logged in so to access the exercise i'm
going to click on academy
select the learning path
go down select sql injection because
that's the module we're working with
go down again
select sql injection union attacks
so that's the lab we did in the previous
lab which is step number one
of union based sql injection attacks and
today we're going to be doing step
number two so sql injection union attack
finding a column containing
text i'm going to right click and open
that in a new tab
okay before we solve the exercise we
need to cover
a little bit of theory on how the union
operator works
i've got the notes document to open from
the previous lab because we covered the
first portion of it there
and today we'll be covering the second
portion so
in the previous lab we talked about
having two tables table one and table
two
table one had two columns a and b and
table two had two columns c
and d and this was the content of table
one and this was the content of table
two
now when i wanna combine the results of
two select queries together i can use
the union operator
over here i'm combining the results of
this query
with this query over here so select
amb from table 1 so select all the
entries in columns a and b
from table 1 would output one two three
four
and then select c and d from table two
so select all the entries from column
c and d from table two would output the
entries
in table two so two three and four five
and using the union operator over here
combines the results together so you see
over here you've got one two
three four that's the result of the
first query
and two three four five that's the
result of the second query
and that's the way that the union
operator works now
you can just simply combine the results
of any two queries together
instead you have to comply by the rules
of the union operator
and there are two we discussed that in
the previous lab so the number and the
order of the columns must be
the same in all queries you've got over
here the number of columns a and b
is 2 and then the number of columns in
the second query is also 2 and that's
why you're
satisfying the first rule the second
rule is that the data types must be
compatible you'll see over here the data
types of columns a and b
is integer an integer and then the data
types of columns c
and d is also integer and integer and
that's why this query gives you
the results so a 200 response versus
giving you an error because you do
comply with the rules of the union
operator
now when you're conducting a sql
injection attack from a black box
perspective
you don't actually know the number of
columns that the query
is using and you don't know the data
types of the
columns that the query is using and
that's why you need to figure those two
types out
that's step number one and step number
two in a union-based sql injection
attack
and we talked about step number one in
the first lap so i'm just going to
label this step number one
german number
of columns we said there were two ways
of doing this one
is iteratively adding select null
statements so if you have a query over
here
so select a certain number of columns
from table one
again you don't know the number of
columns because you're approaching it
from a black box perspective
so what you could do is add union select
null
and if the number of columns in this
query
is not compatible with the number of
columns in this query then you would get
an
error and that's an indication that you
didn't use the number
the correct number of columns and so
what you do
is add another null value and if you
still get an error that means you know
that it doesn't have just two columns
and then you keep doing that iteratively
until you get a 200 response code which
is what you're getting over here after
you've added three null values
and that means that you've reached the
correct number of columns
and the number of columns is the number
of null values that you added
so because i have three null values i
know that the query uses three columns
that's way number one of determining the
number of columns way number two is to
use the order by clause which orders
by the column that you give it and so
over here if i say order by one
it'll order by the first column and you
get a 200 response code if i say order
by two
it'll order by the second column and you
get a 200 response code
now if i say order by three you're
ordering by a column that does not exist
and so this is going to throw an error
and when i see an error that means
i know that i've reached a column that
does not exist
and so the number of columns that the
query is using
is whatever value i've reached minus 1
so 3 minus one which is two
and you'll see over here that it has two
columns so that was step number one
determining the number of columns
step number two which is the main focus
of the lab today
is to determine the
data type of the columns and the reason
that's important is because
when i'm exploiting a union based sql
injection attack i want to output
interesting things like
the hashed password of a user and the
user names of the users of the
application
and so since these values are of type
text
i would need to output these values in
columns that accept data types of type
text and so i need to find the columns
that have data type
text first in order to be able to output
the content
and so the way to do that is similar to
the one over here
so i know from step number one that my
query
is using three columns
so what i'm going to do is i'm going to
iteratively
add select statements and put a value of
type
text in each column and see if it throws
an error
i start off with the first column
if this throws an error over here
that means the column
is type string
but if it doesn't throw an error
then the column is of type string
over here if this does not throw an
error that means i know column
a is of type string and so i could use
it or i've typed text and so i could use
it
now if it does throw an error that means
i know it's of a different type
and so i can't use it and then the next
thing that i will try
we do this iteratively is i'll use the
second column
and see if this throws an error and then
same goes for the third column
i'll do the same thing and see if this
throws an error
until i've enumerated which columns
allow you to output
data type text all right now that we've
covered the
theory let's start solving the exercise
so the exercise says the slab contains a
sql injection vulnerability in the
product category filter the results from
the query
are returned in the application's
response so you can use a union attack
to retrieve data from other tables
to construct such an attack you first
need to determine the number of columns
returned by the query
you can do this using a technique you
learned in the previous
lab so that's this one over here so how
to determine the number of
columns the next step is to identify a
column that is compatible with string
data
which is step number two
over here that we discussed
the lab will provide a random value that
you need to make appear within the query
results
to solve the lab perform a sql injection
union attack that returns an additional
row
containing the value provided this
techniques helps you determine which
columns are compatible with string data
okay so let's access the lab
and that might take some time in the
meantime i'm going to remove this
and put an analysis top
okay so the vulnerable field is the
category so the product category field
so i'm going to click on gifts over here
and what that does is it filters on the
category gifts
and we could see that in the url over
here so this is about our vulnerable
field and this is where we'll be
conducting
our union-based sql injection attack all
right
like we said step number one is to
determine
the number of columns and i'm going to
use
way number two to do that so
using the order by clause so close off
the query
order by one and then comment out the
rest of the query to see
if it gives me an error or not
let's do that
okay i don't get an error which means
there's at least one column which makes
sense because
you could see over here there has to be
at least a column for the name and then
a column for the
price now let's try order by two
you see over here that it's ordered by
the second column
oh actually no it ordered by the second
column which is one over here
so you've got an id column that exists
but is not shown in the page so that's
interesting
you can't use that to output data on the
page
let's try order by three and you see
over here it ordered by the third
column which is the price column
let's try order by four
okay and we get an error which means
that
it has
three columns
and first column
is not shown on the page
okay that'll come in handy when we're
trying to output data on the page
now the second step is to determine the
data type of the columns
so i know that there's three columns so
my query would look something like this
union select null
null and comment out the rest of the
query so let's try with the first one
although it doesn't really matter if you
try or not because it doesn't get
outputted on the page and so it's pretty
useless to us
you get an error and likely because it's
an id field so it doesn't have
data of type string so let's try
second column
you see over here that it definitely has
data of type string because you've got
alphabets over here so this should work
let's try it
okay and you could see over here that
you outputted data
now let's try the third column
you could keep this over here actually
as it works
by the third column and see if it
outputs an error
and you get an error so the third value
is sorry the third column is also
not a data type string
okay so we only have one column which is
second column of type string
okay and so to complete the exercise we
need to make the database retrieve the
string
over here and so to do that we'll be
outputting
it in the second column put that over
here
and this should successfully solve the
exercise
here we go it says congratulations you
solved the lab
okay so we successfully completed the
exercise
now let's script it and if you're new to
this channel
and you're wondering why i'm scripting
the attack or the exploitation part of
the attack
that's because there will come
situations in your pen testing career
where you
will have to automate the attack and
this is just preparation for that
also this comes in handy when you're
trying to show management
uh the extent of your attack and instead
of having to go through the browser
change a parameter and so on all you
would have to do is run your program and
then with one click you
show the end result of your attack so it
gives your attack vector much more
value and it's just a much more elegant
way of doing it
okay so what i have over here is the
script that we wrote from lab three
and the reason i have it up is because
it's the same application
and in this script over here we did step
number one and so i didn't want to write
it again
we'll just modify the script to do step
number two as well
okay let's do terminal
new terminal and we're in lab number
four that's good
and let's run it to see what this does
dot py and we need the url
so this might have timed out
and it did so let's open a new one
and while that opens up i'm gonna open
up burp as well
close next bar burp
okay over here turn intercept
off and you'll see over here we've got
it at localhost 8080.
okay i'm going to make this smaller
and put it over here okay
so let's see what the script does first
you'll see over here
in the main method it takes in one
argument which is the url
of the application and that's what we're
going to do in a bit and then
it saves it in the variable url
and then it prints out figuring out the
number of columns there it calls the
function
exploit sqli column number and
if it returns a result then outputs the
number of columns is blah blah otherwise
it outputs the sqli
attack was not successful let's look at
this function over here
you've got the path set to filter and
then the category
parameter which is the vulnerable
parameter and then it loops
through 1 to 50 and then it iteratively
tries
each value between 1 and 50 and if it
gets an internal server then
it will return the i value minus 1 which
means that you're trying to order by a
column that does not exist and so the
number of columns that the application
has is i minus one otherwise it
increases the value of i
and then it runs this whole process
again now
50 is something that i arbitrarily
picked last time
because i can tell that the application
has less than 50
columns but this is definitely an
assumption that we're making
okay and so it should output the number
of columns after that
let's take the url of the application
copy that
put it over here
and hit enter
and it tells you the number of columns
is three
and if you go to burp
in the history tab you'll see it tried
one first
it tried two it tried three
it got 200 response codes for all of
them and then it tried four
it got an internal server error and
that's why i outputted
four minus one which is three all right
so we want to
edit this script so that it also tries
to figure out the data type of the
columns okay to do that we'll start over
here
let's print figuring out
which column contains
x and then
create a variable called string column
and the new function called exploit sqli
bring field
and it takes in the url and then columns
and then if
evaluates to true then print
a column that contains
next is
the value of string column
otherwise i wanted to print
that it didn't find a column that
contains text
which is possible sometimes so we were
not
able to find
column
a string data type
okay
i'm going to make this i'm going to save
this and make this a little bit smaller
and this way we could see the entire
thing all right so what we're doing over
here
is once it's figured out the number of
columns
i wanted to figure out the type of
data that the column accepts and it does
that by running this function over here
which we will
implement right now let's create a new
function
the exploit sqli
ring field and it takes in the url
and the number of columns
and again the path is the same path over
here so i'm just going to copy that
and then i'm going to say for i in range
between 1 and the number of columns
plus 1. so
for i in the range 1 and the number of
columns so we know that the number of
columns because we did this manually we
know that the number of columns is three
so it'll try one two three
and then we'll do the string is equal to
so this is the string that we want to
output on the page
and it's this one over here
and then i'm going to create a list
called payload list
and then fill it with null values and
the number of null values is the number
of columns that we found
on this function so null times
um call and then i'm going to say
list
i minus 1 because it starts off with
index zero
is equal to the string
okay and then sql payload
union select
join list and then we
comment peeled over here okay and i'll
explain this in a second let's just
finish off the function
it makes a request
so the url plus the path plus the sql
payload
verify set false
and the response gets saved in a
variable
res so r dot text
and then if string dot
as in the response and return i
otherwise return
okay all right
so in order to find the column
that contains data of type string what i
need to do is i need to run
a bunch of union select null statements
right so in this scenario what we did
is we're doing this
we start off with the first one and we
put a certain string so let's say a in
this case
and then we run this and then
we loop through it again
if we get an error we loop through it
again
except in this scenario
we put it in the second column and so on
then we do it for the third column and
so on and that's what the function is
doing
so the path is the path to the
vulnerable parameter
and then it's looping through the number
of columns which is what we got from
this function over here
it creates a payload list so it creates
a list
that contains a bunch of null values
that represent the number of columns
that
are in the sql function and then it sets
the i value so the one that we're
currently looping with
to the string value so the string that
we need to output in the page
and then it calls the request now if it
finds
that the string is represented in the
page so if it sees it somewhere over
here
then it returns that number so that's
the column number
that is able to contain data of type a
string or of type text
and so it returns it and it'll output it
on the page otherwise it will
loop through the next column and so on
and if it doesn't find a column it'll
return
false now what we're doing over here is
string
so that's a string over here dot strip
so what we're doing
is we're stripping it out of the single
quote over here because the single quote
doesn't actually appear on the page
if you just compare it on the string
value itself which is this one over here
you won't find it on the page because
the single quotes do not get represented
on the page this is just for the back
end
equal query and that's why we're doing
that okay let's save it and see if
there's
any errors so python3
sqli lab four
dot py and again i'm gonna
see if this timed out and it didn't i'm
just going to copy this
okay hit enter and it says oh
it's lab number three
so we get an error and the error is in
line number
24 and that's because
they load let's leave that again
okay it's figuring out the number of
columns
and we get one more error and that's in
line number 25.
so the error over here
is also the less so payload
less
hopefully it should work and she didn't
give you an error okay this is a good
sign
awesome so it says we're figuring out
the number of columns and then it
figures out
it's three and then it tries to figure
out the column that contains
data type text or data type string and
then it says the column that contains
uh text is to so we go
here
i'm just gonna put a space so that it
looks a little bit better
and save this
and let's look at burp i'm gonna run it
one more time
okay
all right so you could see over here
it tries to order by one and then it
orders by two orders by three orders by
four
it finds the internal server error and
that's why it knows that the number of
columns
is four minus one which is three and
then it outputs this over here
next it's trying to find the column that
contains value type
text so it starts off with the first one
and it gets an internal server error so
it knows that the first column
does not accept data type text it tries
a second column
over here and it gets a 200 response it
checks
what this does over here is checks if
the string is
in the response let's do that
b2f and
6u a and it says i found two matches
there we go so it's in the response so
it knows that the second column
accepts data type text or data type
string and that's why
it outputs a column that contains text
is two
okay so we've successfully completed the
exercise to recap in this video we first
manually ran a sql injection union
attack
in order to determine which columns
contain data
of type text we then scripted that
exploit so that it automatically does
that for us in the next stop we'll learn
how to
actually extract data from the database
and output the usernames and passwords
of the users of the application
if you like the video hit the subscribe
and share button so that it reaches a
wider
audience also comment below what you
learned and what you would like to see
more of in the future
thank you and see you in the next video